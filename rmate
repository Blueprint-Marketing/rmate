#!/usr/bin/ruby -wKU
require 'optparse'
require 'socket'
require "fileutils"

force = false
OptionParser.new do |o|
  o.on('-f', '--force', 'Open even if the file is not writable.') do |b|
    force = b
  end
  o.parse!
end
    

host, port = '127.0.0.1', 52698

if conn = ENV['SSH_CONNECTION']
  host = conn.split(' ').first 
end

socket = TCPSocket.new(host, port)
puts "Connect: ‘#{socket.readline.chomp}’"

class Command
   def initialize(name)
     @command   = name
     @variables = {}
     @data      = nil
     @size      = nil
   end

   def []=(name, value)
     @variables[name] = value
   end

   def read_file(path)
     @size = File.size(path)
     @data = File.open(path, "rb") { |io| io.read(@size) }
   end

   def send(socket)
     socket.puts @command
     @variables.each_pair do |name, value|
       value = 'yes' if value === true
       socket.puts "#{name}: #{value}"
     end
     if @data
       socket.puts "data: #{@size}"
       socket.puts @data
     end
     socket.puts
   end
end

ARGV.each do |path|
  abort "File #{path} is not writable! Use -f/--force to open anyway." unless force or File.writable? path
  $stderr.puts "File #{path} is not writable. Opening anyway." if not File.writable? path
  cmd                 = Command.new("open")
  cmd['display-name'] = "#{Socket.gethostname}:#{path}"
  cmd['real-path']    = File.expand_path(path)
  cmd['data-on-save'] = true
  cmd['re-activate']  = true
  cmd['token']        = path
  cmd.read_file(path)               if File.exist? path
  cmd['data']         = "0"     unless File.exist? path
  cmd.send(socket)
end

socket.puts "."

def handle_save(socket, variables, data)
  path = variables["token"]
  $stderr.puts "Saving #{path}"
  begin
    FileUtils.cp(path, "#{path}~") if File.exist? path
    File.open(path, 'w') { |file| file << data }
    File.unlink("#{path}~")        if File.exist? "#{path}~"
  rescue
    # TODO We probably want some way to notify the server app that the save failed
    $stderr.puts "Save failed! #{$!}"
  end
end

def handle_close(socket, variables, data)
  path = variables["token"]
  $stderr.puts "Closed #{path}"
end

def handle_cmd(socket)
  cmd = socket.readline.chomp

  variables = {}
  data = ""

  while line = socket.readline.chomp
    break if line.empty?
    name, value     = line.split(': ', 2)
    variables[name] = value
    data << socket.read(value.to_i) if name == "data"
  end
  variables.delete("data")

  case cmd
  when "save"   then handle_save(socket, variables, data)
  when "close"  then handle_close(socket, variables, data)
  else          abort "Received unknown command “#{cmd}”, exiting."
  end
end

handle_cmd(socket) while !socket.eof?

socket.close

$stderr.puts "Done"
